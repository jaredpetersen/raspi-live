package main

import (
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"regexp"
	"strconv"
	"strings"
	"sync"

	"github.com/jaredpetersen/raspilive/internal/ffmpeg/dash"
	"github.com/jaredpetersen/raspilive/internal/ffmpeg/hls"
	"github.com/jaredpetersen/raspilive/internal/raspivid"
	"github.com/kelseyhightower/envconfig"
)

// TODO create server directory if it does not exist
// TODO research application logging

// VideoConfig represents the configuration for the video source.
type VideoConfig struct {
	Width          int `default:"1920"`
	Height         int `default:"1080"`
	Fps            int `default:"30"`
	HorizontalFlip bool
	VerticalFlip   bool
}

// HlsConfig represents the configuraiton for HLS.
type HlsConfig struct {
	Port         int    `required:"true"`
	Directory    string `default:"./camera"`
	SegmentType  string // Segment video type
	SegmentTime  int    // Segment length target duration in seconds
	PlaylistSize int    // Maximum number of playlist entries
	StorageSize  int    // Maximum number of unreferenced segments to keep on disk before removal
}

// DashConfig represents the configuraiton for HLS.
type DashConfig struct {
	Port         int    `required:"true"`
	Directory    string `default:"./camera"`
	SegmentType  string // Segment video type
	SegmentTime  int    // Segment length target duration in seconds
	PlaylistSize int    // Maximum number of playlist entries
	StorageSize  int    // Maximum number of unreferenced segments to keep on disk before removal
}

// Config represents the configuration for raspilive.
type Config struct {
	Mode  string `required:"true"`
	Video VideoConfig
}

// Muxer is a video transformation device for modifying raw video into a format suitable for the user.
type Muxer interface {
	Mux(video io.ReadCloser) error
	Wait() error
}

func main() {
	// Envconfig's nested struct parsing breaks down with nested structs that have required tags
	// so we keep the configs for each of the different modes separate
	var config Config
	err := envconfig.Process("raspilive", &config)
	if err != nil {
		log.Fatal(err)
	}

	raspiOptions := raspivid.Options{
		Width:          config.Video.Width,
		Height:         config.Video.Height,
		Fps:            config.Video.Fps,
		HorizontalFlip: config.Video.HorizontalFlip,
		VerticalFlip:   config.Video.VerticalFlip,
	}
	raspiStream, err := raspivid.NewStream(raspiOptions)
	if err != nil {
		log.Fatal(err)
	}

	switch strings.ToUpper(config.Mode) {
	case "HLS":
		var hlsConfig HlsConfig
		err := envconfig.Process("raspilive_hls", &hlsConfig)
		if err != nil {
			log.Fatal(transformError(err))
		}

		muxer := hls.Muxer{
			Directory: hlsConfig.Directory,
			Options: hls.Options{
				Fps:          config.Video.Fps,
				SegmentType:  hlsConfig.SegmentType,
				SegmentTime:  hlsConfig.SegmentTime,
				PlaylistSize: hlsConfig.PlaylistSize,
				StorageSize:  hlsConfig.StorageSize,
			},
		}
		server := newStaticServer(hlsConfig.Port, hlsConfig.Directory)
		muxAndServe(*raspiStream, &muxer, server)
	case "DASH":
		var dashConfig DashConfig
		err := envconfig.Process("raspilive_dash", &dashConfig)
		if err != nil {
			log.Fatal(transformError(err))
		}

		muxer := dash.Muxer{
			Directory: dashConfig.Directory,
			Options: dash.Options{
				Fps:          config.Video.Fps,
				SegmentType:  dashConfig.SegmentType,
				SegmentTime:  dashConfig.SegmentTime,
				PlaylistSize: dashConfig.PlaylistSize,
				StorageSize:  dashConfig.StorageSize,
			},
		}
		server := newStaticServer(dashConfig.Port, dashConfig.Directory)
		muxAndServe(*raspiStream, &muxer, server)
	default:
		log.Println("Invalid streaming mode")
		os.Exit(1)
	}
}

func muxAndServe(raspiStream raspivid.Stream, muxer Muxer, server *http.Server) {
	// If any member of the wait group ends early, quit
	var wg sync.WaitGroup
	wg.Add(1)

	// Serve files generated by the video stream
	go func() {
		log.Println("Server started", server.Addr)
		log.Fatal(server.ListenAndServe())
		wg.Done()
	}()

	// Stream video
	go func() {
		log.Fatal(mux(raspiStream, muxer))
		wg.Done()
	}()

	wg.Wait()
}

func mux(raspiStream raspivid.Stream, muxer Muxer) error {
	err := muxer.Mux(raspiStream.Video)
	if err != nil {
		return err
	}

	err = raspiStream.Start()
	if err != nil {
		return err
	}

	// If any member of the wait group ends early, quit
	var wg sync.WaitGroup
	wg.Add(1)

	go func() {
		log.Fatal(raspiStream.Wait())
		wg.Done()
	}()

	go func() {
		log.Fatal(muxer.Wait())
		wg.Done()
	}()

	wg.Wait()

	return nil
}

func newStaticServer(port int, directory string) *http.Server {
	router := http.NewServeMux()
	router.Handle("/camera", http.FileServer(http.Dir(directory)))

	return &http.Server{
		Addr:    ":" + strconv.Itoa(port),
		Handler: router,
	}
}

// transformError converts errors into something we want to show users.
func transformError(err error) error {
	pattern := regexp.MustCompile(`required key ([A-Z_]*) missing value`)
	matches := pattern.FindStringSubmatch(fmt.Sprint(err))

	var newErr error

	if matches != nil {
		newErr = fmt.Errorf("Required config key %s is missing", matches[1])
	} else {
		newErr = err
	}

	return newErr
}
