package main

import (
	"io"
	"log"
	"net/http"
	"os"
	"strconv"
	"strings"
	"sync"

	"github.com/jaredpetersen/raspilive/internal/ffmpeg/hls"
	"github.com/jaredpetersen/raspilive/internal/ffmpeg/mpegdash"
	"github.com/jaredpetersen/raspilive/internal/raspivid"
	"github.com/kelseyhightower/envconfig"
)

// TODO create server directory if it does not exist
// TODO research application logging

// VideoConfig represents the configuration for the video source.
type VideoConfig struct {
	Width          int `default:"1920"`
	Height         int `default:"1080"`
	Fps            int `default:"30"`
	HorizontalFlip bool
	VerticalFlip   bool
}

// HlsConfig represents the configuraiton for HLS.
type HlsConfig struct {
	Port         int    `required:"true"`
	Directory    string `default:"./camera"`
	SegmentTime  int    // Segment length target duration in seconds
	PlaylistSize int    // Maximum number of playlist entries
	StorageSize  int    // Maximum number of unreferenced segments to keep on disk before removal
}

// MpegdashConfig represents the configuraiton for HLS.
type MpegdashConfig struct {
	Port         int    `required:"true"`
	Directory    string `default:"./camera"`
	SegmentTime  int    // Segment length target duration in seconds
	PlaylistSize int    // Maximum number of playlist entries
	StorageSize  int    // Maximum number of unreferenced segments to keep on disk before removal
}

// Config represents the configuration for raspilive.
type Config struct {
	Mode     string `required:"true"`
	Video    VideoConfig
	Hls      HlsConfig
	Mpegdash MpegdashConfig
}

// Muxer is a video transformation device for modifying raw video into a format suitable for the user.
type Muxer interface {
	Start(video io.ReadCloser) error
	Wait() error
}

func main() {
	var config Config
	err := envconfig.Process("raspilive", &config)
	if err != nil {
		log.Fatal(err.Error())
	}

	raspividStream := raspivid.Stream{
		Width:          config.Video.Width,
		Height:         config.Video.Height,
		Fps:            config.Video.Fps,
		HorizontalFlip: config.Video.HorizontalFlip,
		VerticalFlip:   config.Video.VerticalFlip,
	}

	switch strings.ToUpper(config.Mode) {
	case "HLS":
		muxer := hls.Muxer{
			Directory:    config.Hls.Directory,
			Fps:          config.Video.Fps,
			SegmentTime:  config.Hls.SegmentTime,
			PlaylistSize: config.Hls.PlaylistSize,
			StorageSize:  config.Hls.StorageSize,
		}
		server := newStaticServer(config.Hls.Port, config.Hls.Directory)
		muxAndServe(raspividStream, &muxer, server)
	case "MPEGDASH":
		muxer := mpegdash.Muxer{
			Directory:    config.Hls.Directory,
			Fps:          config.Video.Fps,
			SegmentTime:  config.Hls.SegmentTime,
			PlaylistSize: config.Hls.PlaylistSize,
			StorageSize:  config.Hls.StorageSize,
		}
		server := newStaticServer(config.Mpegdash.Port, config.Mpegdash.Directory)
		muxAndServe(raspividStream, &muxer, server)
	default:
		log.Println("Invalid streaming mode")
		os.Exit(1)
	}
}

func muxAndServe(raspividStream raspivid.Stream, muxer Muxer, server *http.Server) {
	var wg sync.WaitGroup
	wg.Add(2)

	// Serve files generated by the video stream
	go func() {
		log.Println("Server started", server.Addr)
		log.Fatal(server.ListenAndServe())
		wg.Done()
	}()

	// Stream video
	go func() {
		log.Fatal(mux(raspividStream, muxer))
		wg.Done()
	}()

	wg.Wait()
}

func mux(raspividStream raspivid.Stream, muxer Muxer) error {
	videoStream, err := raspividStream.Start()

	if err != nil {
		return err
	}

	err = muxer.Start(videoStream)

	if err != nil {
		return err
	}

	// Wait for everything to complete
	raspividStream.Wait()
	muxer.Wait()

	return nil
}

func newStaticServer(port int, directory string) *http.Server {
	router := http.NewServeMux()
	router.Handle("/camera", http.FileServer(http.Dir(directory)))

	return &http.Server{
		Addr:    ":" + strconv.Itoa(port),
		Handler: router,
	}
}
