package main

import (
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"regexp"
	"strconv"
	"strings"
	"sync"

	"github.com/jaredpetersen/raspilive/internal/ffmpeg/dash"
	"github.com/jaredpetersen/raspilive/internal/ffmpeg/hls"
	"github.com/jaredpetersen/raspilive/internal/raspivid"
	"github.com/kelseyhightower/envconfig"
)

// TODO create server directory if it does not exist
// TODO research application logging

// VideoConfig represents the configuration for the video source.
type VideoConfig struct {
	Width          int `default:"1920"`
	Height         int `default:"1080"`
	Fps            int `default:"30"`
	HorizontalFlip bool
	VerticalFlip   bool
}

// HlsConfig represents the configuraiton for HLS.
type HlsConfig struct {
	Port         int    `required:"true"`
	Directory    string `default:"./camera"`
	SegmentType  string // Segment video type
	SegmentTime  int    // Segment length target duration in seconds
	PlaylistSize int    // Maximum number of playlist entries
	StorageSize  int    // Maximum number of unreferenced segments to keep on disk before removal
}

// MpegdashConfig represents the configuraiton for HLS.
type MpegdashConfig struct {
	Port         int    `required:"true"`
	Directory    string `default:"./camera"`
	SegmentTime  int    // Segment length target duration in seconds
	PlaylistSize int    // Maximum number of playlist entries
	StorageSize  int    // Maximum number of unreferenced segments to keep on disk before removal
}

// Config represents the configuration for raspilive.
type Config struct {
	Mode  string `required:"true"`
	Video VideoConfig
}

// Muxer is a video transformation device for modifying raw video into a format suitable for the user.
type Muxer interface {
	Start(video io.ReadCloser) error
	Wait() error
}

func main() {
	// Envconfig's nested struct parsing breaks down with nested structs that have required tags
	// so we keep the configs for each of the different modes separate
	var config Config
	err := envconfig.Process("raspilive", &config)
	if err != nil {
		log.Fatal(err)
	}

	raspividStream := raspivid.Stream{
		Width:          config.Video.Width,
		Height:         config.Video.Height,
		Fps:            config.Video.Fps,
		HorizontalFlip: config.Video.HorizontalFlip,
		VerticalFlip:   config.Video.VerticalFlip,
	}

	switch strings.ToUpper(config.Mode) {
	case "HLS":
		var hlsConfig HlsConfig
		err := envconfig.Process("raspilive_hls", &hlsConfig)
		if err != nil {
			log.Fatal(rewriteEnvconfigErr(err))
		}

		muxer := hls.Muxer{
			Directory:    hlsConfig.Directory,
			Fps:          config.Video.Fps,
			SegmentTime:  hlsConfig.SegmentTime,
			PlaylistSize: hlsConfig.PlaylistSize,
			StorageSize:  hlsConfig.StorageSize,
		}
		server := newStaticServer(hlsConfig.Port, hlsConfig.Directory)
		muxAndServe(raspividStream, &muxer, server)
	case "DASH":
		var mpegdashConfig MpegdashConfig
		err := envconfig.Process("raspilive_dash", &mpegdashConfig)
		if err != nil {
			log.Fatal(rewriteEnvconfigErr(err))
		}

		muxer := dash.Muxer{
			Directory:    mpegdashConfig.Directory,
			Fps:          config.Video.Fps,
			SegmentTime:  mpegdashConfig.SegmentTime,
			PlaylistSize: mpegdashConfig.PlaylistSize,
			StorageSize:  mpegdashConfig.StorageSize,
		}
		server := newStaticServer(mpegdashConfig.Port, mpegdashConfig.Directory)
		muxAndServe(raspividStream, &muxer, server)
	default:
		log.Println("Invalid streaming mode")
		os.Exit(1)
	}
}

func muxAndServe(raspividStream raspivid.Stream, muxer Muxer, server *http.Server) {
	var wg sync.WaitGroup
	wg.Add(2)

	// Serve files generated by the video stream
	go func() {
		log.Println("Server started", server.Addr)
		log.Fatal(server.ListenAndServe())
		wg.Done()
	}()

	// Stream video
	go func() {
		log.Fatal(mux(raspividStream, muxer))
		wg.Done()
	}()

	wg.Wait()
}

func mux(raspividStream raspivid.Stream, muxer Muxer) error {
	videoStream, err := raspividStream.Start()

	if err != nil {
		return err
	}

	err = muxer.Start(videoStream)

	if err != nil {
		return err
	}

	// Wait for everything to complete
	raspividStream.Wait()
	muxer.Wait()

	return nil
}

func newStaticServer(port int, directory string) *http.Server {
	router := http.NewServeMux()
	router.Handle("/camera", http.FileServer(http.Dir(directory)))

	return &http.Server{
		Addr:    ":" + strconv.Itoa(port),
		Handler: router,
	}
}

// rewriteEnvconfigErr converts errors from the envconfig package into something we want to show users.
func rewriteEnvconfigErr(err error) error {
	pattern := regexp.MustCompile(`required key ([A-Z_]*) missing value`)
	matches := pattern.FindStringSubmatch(fmt.Sprint(err))

	var newErr error

	if matches != nil {
		newErr = fmt.Errorf("Required config key %s is missing", matches[1])
	} else {
		newErr = err
	}

	return newErr
}
