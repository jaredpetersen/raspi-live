package cmd

import (
	"fmt"
	"io"
	"log"
	"net/http"
	"regexp"
	"strconv"
	"sync"

	"github.com/jaredpetersen/raspilive/internal/raspivid"
	"github.com/spf13/cobra"
)

// TODO create server directory if it does not exist
// TODO research application logging

// VideoConfig represents the configuration for the video source.
type VideoConfig struct {
	Width          int `default:"1920"`
	Height         int `default:"1080"`
	Fps            int `default:"30"`
	HorizontalFlip bool
	VerticalFlip   bool
}

// DashConfig represents the configuraiton for HLS.
type DashConfig struct {
	Port         int    `required:"true"`
	Directory    string `default:"./camera"`
	SegmentTime  int    // Segment length target duration in seconds
	PlaylistSize int    // Maximum number of playlist entries
	StorageSize  int    // Maximum number of unreferenced segments to keep on disk before removal
}

// Muxer is a video transformation device for modifying raw video into a format suitable for the user.
type Muxer interface {
	Mux(video io.ReadCloser) error
	Wait() error
}

var port int
var directory string
var segmentTime int
var playlistSize int
var storageSize int

func init() {
	hlsCmd.Flags().IntVar(&port, "port", 0, "Static file server port (required)")
	hlsCmd.MarkFlagRequired("port")

	hlsCmd.Flags().StringVar(&directory, "directory", "", "Static file server directory (required)")
	hlsCmd.MarkFlagRequired("directory")

	hlsCmd.Flags().IntVar(&segmentTime, "segment-time", 0, "Segment length target duration in seconds")

	hlsCmd.Flags().IntVar(&playlistSize, "playlist-size", 0, "Maximum number of playlist entries")

	hlsCmd.Flags().IntVar(&storageSize, "storage-size", 0, "Maximum number of unreferenced segments to keep on disk before removal")

	hlsCmd.Flags().SortFlags = false
	rootCmd.AddCommand(hlsCmd)
}

var hlsCmd = &cobra.Command{
	Use:   "hls",
	Short: "Stream video using the HLS streaming technology",
	Run:   run,
}

func run(cmd *cobra.Command, args []string) {
	// raspiOptions := raspivid.Options{
	// 	Width:          config.Video.Width,
	// 	Height:         config.Video.Height,
	// 	Fps:            config.Video.Fps,
	// 	HorizontalFlip: config.Video.HorizontalFlip,
	// 	VerticalFlip:   config.Video.VerticalFlip,
	// }
	// raspiStream, err := raspivid.NewStream(raspiOptions)
	// if err != nil {
	// 	log.Fatal(err)
	// }

	// muxer := dash.Muxer{
	// 	Directory: dashConfig.Directory,
	// 	Options: dash.Options{
	// 		Fps:          config.Video.Fps,
	// 		SegmentTime:  dashConfig.SegmentTime,
	// 		PlaylistSize: dashConfig.PlaylistSize,
	// 		StorageSize:  dashConfig.StorageSize,
	// 	},
	// }
	// server := newStaticServer(port, dashConfig.Directory)
	// muxAndServe(*raspiStream, &muxer, server)
}

func muxAndServe(raspiStream raspivid.Stream, muxer Muxer, server *http.Server) {
	// If any member of the wait group ends early, quit
	var wg sync.WaitGroup
	wg.Add(1)

	// Serve files generated by the video stream
	go func() {
		log.Println("Server started", server.Addr)
		log.Fatal(server.ListenAndServe())
		wg.Done()
	}()

	// Stream video
	go func() {
		log.Fatal(mux(raspiStream, muxer))
		wg.Done()
	}()

	wg.Wait()
}

func mux(raspiStream raspivid.Stream, muxer Muxer) error {
	err := muxer.Mux(raspiStream.Video)
	if err != nil {
		return err
	}

	err = raspiStream.Start()
	if err != nil {
		return err
	}

	// If any member of the wait group ends early, quit
	var wg sync.WaitGroup
	wg.Add(1)

	go func() {
		err = raspiStream.Wait()
		wg.Done()
	}()

	go func() {
		err = muxer.Wait()
		wg.Done()
	}()

	wg.Wait()

	return nil
}

func newStaticServer(port int, directory string) *http.Server {
	router := http.NewServeMux()
	router.Handle("/camera", http.FileServer(http.Dir(directory)))

	return &http.Server{
		Addr:    ":" + strconv.Itoa(port),
		Handler: router,
	}
}

// transformError converts errors into something we want to show users.
func transformError(err error) error {
	pattern := regexp.MustCompile(`required key ([A-Z_]*) missing value`)
	matches := pattern.FindStringSubmatch(fmt.Sprint(err))

	var newErr error

	if matches != nil {
		newErr = fmt.Errorf("Required config key %s is missing", matches[1])
	} else {
		newErr = err
	}

	return newErr
}
